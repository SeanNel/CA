package ca.shapedetector;

import helpers.NDArrayList;
import helpers.Stopwatch;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import ca.Cell;
import ca.concurrency.ThreadServer;
import ca.rules.Rule;
import ca.rules.blob.*;
import ca.shapedetector.blob.*;
import exceptions.CAException;

/**
 * Maps cells to blobs and performs operations on the relationships between
 * them.
 * 
 * @author Sean
 */
public class BlobMap<V> {
	/** The ShapeDetector instance. */
	protected final ShapeDetector sd;
	/** Table mapping cells to blobs. */
	protected NDArrayList<Blob<V>> cellBlobAssociations;
	/** Set of unique blobs. */
	protected Set<Blob<V>> blobs;
	/** Processes to apply to each blob in sequence. */
	protected final List<Rule<Blob<V>>> blobRules;

	/**
	 * Constructor.
	 * 
	 * @param sd
	 * @param shapeList
	 */
	public BlobMap(ShapeDetector sd, ShapeList shapeList) {
		this.sd = sd;

		blobRules = new LinkedList<Rule<Blob<V>>>();
		blobRules.add(new BlobIdentifierRule<V>(this, shapeList));
		// blobRules.add(new BlobDisplayRule(this, graphics.ShapeFrame.panel));
		// blobRules.add(new BlobDrawRule((SDPictureFrame) sd.getPictureFrame(),
		// this));
	}

	/**
	 * Clears all blob associations and the list of blobs.
	 * 
	 * @param w
	 * @param h
	 */
	public void clear(final int w, final int h) {
		cellBlobAssociations = new NDArrayList<Blob<V>>(w, h);
		blobs = new HashSet<Blob<V>>(w * h);
	}

	/**
	 * Applies the blob rules to all found blobs.
	 * 
	 * @throws CAException
	 */
	protected void apply() throws CAException {
		Stopwatch ruleStopwatch = new Stopwatch();
		/*
		 * Attempt to eliminate the blob generated by the background. (Assumes
		 * the top-left corner is part of the background.)
		 */
		blobs.remove(cellBlobAssociations.get(0, 0));

		/*
		 * To ease debugging, sorts the shapes in some kind of order instead of
		 * at random.
		 */
		// blobs = BlobSorter.sortBlobs(blobs);

		for (Rule<Blob<V>> rule : blobRules) {
			rule.prepare();
			if (ShapeDetector.debug) {
				/* Linear method. For easier debugging. */
				for (Blob<V> blob : blobs) {
					rule.update(blob);
				}
			} else {
				/* Multithreaded method. For improved performance. */
				ThreadServer<Blob<V>> threadServer = new ThreadServer<Blob<V>>(
						rule, blobs.iterator(), sd.getCA().getNumThreads());
				threadServer.run();
			}
			rule.complete();
			System.out.println(rule + ", elapsed time: " + ruleStopwatch.time()
					+ " ms");
		}
	}

	/**
	 * Merges two cells' blobs together.
	 * 
	 * @param cell1
	 *            1st cell to merge with.
	 * @param cell2
	 *            2nd cell to merge with.
	 * @return The resulting blob.
	 * @throws CAException
	 */
	public synchronized Blob<V> mergeCells(final Cell<V> cell1,
			final Cell<V> cell2) throws CAException {
		return mergeBlobs(getBlob(cell1), getBlob(cell2));
	}

	/**
	 * Merges 2 blobs together.
	 * 
	 * @see CAblobMergerThread
	 * @param blob1
	 *            1st blob to merge with.
	 * @param blob2
	 *            2st blob to merge with.
	 * @return The resulting blob.
	 * @throws CAException
	 */
	protected Blob<V> mergeBlobs(final Blob<V> blob1, final Blob<V> blob2)
			throws CAException {
		/* NB */
		if (blob1 == blob2) {
			return null;
		}
		synchronized (blob1) {
			synchronized (blob2) {
				/*
				 * Improves efficiency by merging the smaller blob into the
				 * larger blob.
				 */
				Blob<V> newBlob;
				Blob<V> oldBlob;
				if (blob1.getArea() > blob2.getArea()) {
					newBlob = blob1;
					oldBlob = blob2;
				} else {
					newBlob = blob2;
					oldBlob = blob1;
				}

				for (Cell<V> cell : oldBlob.getAreaCells()) {
					setBlob(cell, newBlob);
				}
				/*
				 * oldBlob must be removed *before* merging. (No need for
				 * synchronizing on blobs.)
				 */
				blobs.remove(oldBlob);
				newBlob.merge(oldBlob);
				return newBlob;
			}
		}
	}

	/**
	 * Gets the blob associated with the specified cell.
	 * 
	 * @param cell
	 *            A cell belonging to a blob.
	 * @return The blob associated with the specified cell.
	 * @throws CAException
	 */
	public Blob<V> getBlob(final Cell<V> cell) throws CAException {
		int[] coordinates = cell.getCoordinates();
		return cellBlobAssociations.get(coordinates);
	}

	/**
	 * Sets the blob associated with the specified cell.
	 * 
	 * @param cell
	 *            A cell that is to belong to the blob.
	 * @param shape
	 *            The blob to be associated with the specified cell.
	 * @throws CAException
	 */
	public void setBlob(final Cell<V> cell, final Blob<V> blob)
			throws CAException {
		int[] coordinates = cell.getCoordinates();
		cellBlobAssociations.set(blob, coordinates);
	}

	/**
	 * Adds the specified blob to the list.
	 * 
	 * @param blob
	 */
	public void addBlob(final Blob<V> blob) {
		synchronized (blobs) {
			blobs.add(blob);
		}
	}
}
