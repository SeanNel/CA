package ca.shapedetector;

import helpers.Stopwatch;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import ca.Cell;
import ca.rules.blob.*;
import ca.shapedetector.blob.*;
import exceptions.CAException;

public class BlobMap {
	/** Table mapping cells to blobs. */
	protected Blob[][] cellBlobAssociations;
	/** Set of unique blobs. */
	protected Set<Blob> blobs;
	/** Processes to apply to each blob in sequence. */
	public List<BlobRule> blobRules;

	public void load(ShapeDetector ca) {
		int width = ca.getResult().width();
		int height = ca.getResult().height();
		cellBlobAssociations = new Blob[width][height];
		blobs = new HashSet<Blob>(width * height);
		loadRules(ca);
	}

	protected void loadRules(ShapeDetector ca) {
		blobRules = new LinkedList<BlobRule>();
		blobRules.add(new BlobIdentifierRule(this, ca.getShapeList()));
		// blobRules.add(new BlobDisplayRule(this, ShapeFrame.frame));
		// blobRules.add(new BlobDrawRule((SDPictureFrame) ca.getPictureFrame(),
		// this));
	}

	protected void update() throws CAException {
		Stopwatch ruleStopwatch = new Stopwatch();
		/*
		 * Attempt to eliminate the blob generated by the background. (Assumes
		 * the top-left corner is part of the background.)
		 */
		blobs.remove(cellBlobAssociations[0][0]);

		/*
		 * To ease debugging, sort the shapes in some kind of order instead of
		 * at random.
		 */
		blobs = BlobSorter.sortBlobs(blobs);

		for (BlobRule rule : blobRules) {
			rule.start();
			/* Linear method. For easier debugging. */
			for (Blob blob : blobs) {
				rule.update(blob);
			}
			
			/* Multithreaded method. For improved performance. */
//			ThreadServer<Blob> threadServer = new ThreadServer<Blob>(rule,
//					blobs);
//			threadServer.run();

			rule.end();
			System.out.println(rule + ", elapsed time: " + ruleStopwatch.time()
					+ " ms");
		}
	}

	/**
	 * Merges two cells' blobs together.
	 * 
	 * @param cell1
	 *            1st cell to merge with.
	 * @param cell2
	 *            2nd cell to merge with.
	 * @return The resulting blob.
	 */
	public synchronized Blob mergeCells(Cell cell1, Cell cell2) {
		return mergeBlobs(getBlob(cell1), getBlob(cell2));
	}

	/**
	 * Merges 2 blobs together.
	 * 
	 * @see CAblobMergerThread
	 * @param blob1
	 *            1st blob to merge with.
	 * @param blob2
	 *            2st blob to merge with.
	 * @return The resulting blob.
	 */
	protected Blob mergeBlobs(Blob blob1, Blob blob2) {
		/* NB */
		if (blob1 == blob2) {
			return null;
		}
		synchronized (blob1) {
			synchronized (blob2) {
				/*
				 * Improves efficiency by merging the smaller blob into the
				 * larger blob.
				 */
				Blob newBlob;
				Blob oldBlob;
				if (blob1.getArea() > blob2.getArea()) {
					newBlob = blob1;
					oldBlob = blob2;
				} else {
					newBlob = blob2;
					oldBlob = blob1;
				}

				for (Cell cell : oldBlob.getAreaCells()) {
					setBlob(cell, newBlob);
				}
				/*
				 * oldBlob must be removed *before* merging. No need for
				 * synchronizing on blobs!
				 */
				blobs.remove(oldBlob);
				newBlob.merge(oldBlob);
				return newBlob;
			}
		}
	}

	/**
	 * Gets the blob associated with the specified cell.
	 * 
	 * @param cell
	 *            A cell belonging to a blob.
	 * @return The blob associated with the specified cell.
	 */
	public Blob getBlob(Cell cell) {
		int[] coordinates = cell.getCoordinates();
		return cellBlobAssociations[coordinates[0]][coordinates[1]];
	}

	/**
	 * Sets the blob associated with the specified cell.
	 * 
	 * @param cell
	 *            A cell belonging to a blob.
	 * @param shape
	 *            The blob associated with the specified cell.
	 */
	public void setBlob(Cell cell, Blob blob) {
		int[] coordinates = cell.getCoordinates();
		cellBlobAssociations[coordinates[0]][coordinates[1]] = blob;
	}

	public void addBlob(Blob blob) {
		synchronized (blobs) {
			blobs.add(blob);
		}
	}
}
